# 4 版本操作


## 0 命令手册


### git git add 文件名。
  * 作用：将文件由 工作区 添加到 暂存区，暂存文件
  * git add --all 或者 git add -A 或者git add .（简写） 添加所有文件
  * git add a.txt b.txt 同时添加两个文件
  * git add *.js 添加当前目录下的所有js文件

### git commit
  * 作用：将文件由 暂存区 添加到 仓库区
  * git commit -m "提交说明"

### git checkout 文件名
  * 作用：暂存区的内容恢复到工作区。
  * git checkout 1.txt 将暂存区中1.txt文件恢复到工作区

### git status
  * 作用：查看文件的状态
  * 命令：git status
  * 命令：git stauts -s 简化日志输出格式

### git log
  * 作用：查看提交日志
  * git log 只能查看当前head以及以前的日志
  * git log --oneline 简洁的日志信息
  * git reflog 查看所有的提交变更日志

### git reset
* 作用：版本回退，将代码恢复到已经提交的某一个版本中。
* git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可)
* git reset --hard head~1将版本回退到上一次提交



## 1 git的工作流 

### 提交工作流
* 工作区：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。
* 暂存区：已经 git add xxx 进去，且未 git commit xxx 的。 
* 本地分支：已经git commit -m xxx 提交到本地分支的。 

![](../Git/image/2021-06-15-11-04-57.png)


### 回滚工作流

在上传代码到远程仓库的时候，不免会出现问题，任何过程都有可能要回滚代码：

git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本。
```
git reset --hard HEAD^
```
即往前回退一个版本，回退完了后工作区就是上一个版本的代码了，并且是clean的。
```
git reset --soft HEAD^
```
往前回退一个版本，并且将这次错误的提交的代码改动，放在暂存区里。
```
git reset --mixed HEAD^（和不带参数是一样的）
```
往前回退一个版本，并且将这次错误的提交的代码改动，放在工作区里。


## 2 进阶操作：Git撤销&回滚操作
git reset 和 get revert


### 在工作区的代码
```
git checkout -- a.txt   # 丢弃某个文件，或者
git checkout -- . # 丢弃全部
```

* 注意：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。
* 这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。

### 代码git add到缓存区，并未commit提交
```
git reset HEAD .  或者
git reset HEAD a.txt
```

* 这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化

### git commit到本地分支、但没有git push到远程

```
git log # 得到你需要回退一次提交的commit id
git reset --hard commit_id # 回到其中你想要的某个版
```
或者
```
git reset --hard HEAD^  # 回到最新的一次提交
```
或者
```
git reset --mixed HEAD^  # 此时代码保留，回到 git add 之前，默认就是--mixed
```
* --hard分支、暂存区、工作区都回退到指定版本
* --mixed默认，只改变分支和暂存区的内容，不会改变工作区的内容。
* --soft分支回退到指定版本，不会改变暂存区和工作区。

### git push把修改提交到远程仓库
1. 通过git reset是直接删除指定的commit
```
git log # 得到你需要回退一次提交的commit id
git reset --hard
git push origin HEAD --force # 强制提交一次，之前错误的提交就从远程仓库删除
```
2. 通过git revert是用一次新的commit来回滚之前的commit
```
git log # 得到你需要回退一次提交的commit id
git revert   # 撤销指定的版本，撤销也会作为一次提交进行保存
```
3. git revert 和 git reset的区别

   - git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；
   - git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除

### 场景

* 场景一：糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！

* 场景二：彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！

### 针对场景一

在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！

* 情况一：文件被修改了，但未执行git add操作(working tree内撤销)

``` 
git checkout fileName

git checkout .
```
* 情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件

```
$ git add *

$ git status

# 取消暂存

$ git reset HEAD
```
* 情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）

````
# 取消暂存

git reset HEAD fileName

# 撤销修改

git checkout fileName
````
* 情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit

``` 
# 修改最后一次提交

$ git add sample.txt

$ git commit --amend -m"说明"
```
* 情况五：已在本地进行了多次git commit操作，现在想**撤销到**其中某次Commit
```
git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]
```


### 针对场景二

已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！

如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况
```
git checkout 
```


如果你回到当前HEAD指向
```
git checkout 
```
* 情况一：撤销指定文件到指定版本

```
# 查看指定文件的历史版本

git log

# 回滚到指定commitID

git checkout
```
* 情况二：删除最后一次远程提交

  * 方式一：使用revert
  * 方式二：使用reset


```
git revert HEAD

git push origin master
```

```
git reset --hard HEAD^

git push origin master -f
```
二者区别：

revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；
reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。

* 情况三：回滚某次提交

``` 
# 找到要回滚的commitID

git log

git revert commitID
```
删除某次提交
```
git log --oneline -n5
```

Git撤销&回滚操作(git reset 和 get revert)2
```
git rebase -i "commit id"^
```
注意：需要注意最后的^号，意思是commit id的前一次提交
```
git rebase -i "5b3ba7a"^
```
Git撤销&回滚操作(git reset 和 get revert)3

在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！
```
git push origin master -f
```
通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit


## 3 进阶操作：查看历史git log

### 基本使用
git log能够交互式显示历史信息包括以下内容
* 版本id
* 作者
* 日期
* 提交说明


```log
commit 994d5e4308b984041149676d62c604cfe34ae19b
Author: 法然 <yinkanglong.ykl@alipay.com>
Date:   Wed Jan 4 18:34:05 2023 +0800

    修复sofa-common-configs版本低的问题

commit d3b0fc52e55702f01559f5407810e7f26a7eb0a2 (tag: ER62577606_empub_20221222, origin/EI62577605_20221107, EI62655147_20230104)
Merge: 9c8235f5e 4a0b61c71
Author: 梵茜 <yaomengjie.ymj@digital-engine.com>
Date:   Wed Dec 21 11:20:12 2022 +0800

    PullRequest: 1820 traceplugin-bugfix

    Merge branch 'EI62577605_20221107_traceplugin_bugfix of git@gitlab.alipay-inc.com:jiuzhou-middleware/dsrconsole.git into EI62577605_20221107

    https://code.alipay.com/jiuzhou-middleware/dsrconsole/pull_requests/1820


    Signed-off-by: 省善 <wanghongjia.whj@antgroup.com>
```

### 显示格式

```sh
-p：按补丁显示每个更新间的差异，比下一条- -stat命令信息更全
--stat：显示每次更新的修改文件的统计信息，每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计
--graph：显示ASCII图形表示的分支合并历史
—pretty＝：使用其他格式显示历史提交信息，可选项有：oneline,short,medium,full,fuller,email,raw
```

### 筛选参数

1. 按数量
  * -n：显示前n条log


2. 按日期
   1. --after=  --before=
   2. 比如git log --after="2014-7-1”，显示2014年7月1号之后的commit(包含7月1号)后边的日期还可以用相对时间表示，比如"1 week ago"和”yesterday"，比如git log --after="yesterday"
   3. 而且：可以使用正则表达式，比如git log --author="John\|Mary”，搜索Marry和John贡献的commit
   4. 而且：这个--author不仅包含名还包含email, 所以你可以用这个搜索email

3. 按作者
   1. --author=
   2. 比如git log --author=“John"，显示John贡献的commit

4. 按描述
   1. --grep=
   2. 比如：git log --grep="JRA-224"
   3. 而且：可以传入-i用来忽略大小写
   4. 注意：如果想同时使用--grep和--author，必须在附加一个--all-match参数


5. 按文件
   1. - -（空格）或［没有］
   2. 有时你可能只对某个文件的修改感兴趣, 你只想查看跟某个文件相关的历史信息, 你只需要插入你感兴趣文件的路径［对，是路径，所以经常是不太好用］就可以了
   3. 比如：git log -- foo.py bar.py ，只返回和foo.py或bar.py相关的commit
   4. 这里的--是告诉Git后面的参数是文件路径而不是branch的名字. 如果后面的文件路径不会和某个branch产生混淆, 你可以省略- -，比如git log foo.py 
   5. 另外，后边的路径还支持正则，比如：git log  *install.md 是，指定项目路径下的所有以install.md结尾的文件的提交历史
   6. 另外，文件名应该放到参数的最后位置，通常在前面加上--并用空格隔开表示是文件
   7. 另外，git log file/ 查看file文件夹下所有文件的提交记录

6. 按分支
   1. --
   2. --branchName branchName为任意一个分支名字，查看某个分支上的提交记录
   3. 需要放到参数中的最后位置处
   4. 如果分支名与文件名相同，系统会提示错 误，可通过--选项来指定给定的参数是分支名还是文件名
   5. 比如：在当前分支中有一个名为v1的文件，同时还存在一个名为v1的分支
   6. git log v1 -- 此时的v1代表的是分支名字（－－后边是空的）
   7. git log -- v1 此时的v1代表的是名为v1的文件
   8. git log v1 －－ v1 代表v1分支下的v1文件

7. 按内容
   1. -S"<string>"、-G"<string>"
   2. 有时你想搜索和新增或删除某行代码相关的commit. 可以使用这条命令
   3. 假设你想知道Hello, World!这句话是什么时候加入到项目里去的，可以用：git log -S"Hello,World!"
   4. 另外：如果你想使用正则表达式去匹配而不是字符串, 那么你可以使用-G代替-S.
   5. 这是一个非常有用的debug工具, 使用他你可以定位所有跟某行代码相关的commit. 甚至可以查看某行是什么时候被copy的, 什么时候移到另外一个文件中去的
   6. 注：-S后没有"="，与查询内容之间也没有空格符

8. 按范围
   1. git log <since>..<until>
   2. 这个命令可以查看某个范围的commit
   3. 这个命令非常有用当你使用branch做为range参数的时候. 能很方便的显示2个branch之间的不同
   4. 比如：git log master..feature，master..feature这个range包含了在feature有而在master没有的所有commit，同样，如果是feature..master包含所有master有但是feature没有的commit
   5. 另外，如果是三个点，表示或的意思：git log master...test 查询master或test分支中的提交记录


9. 过滤掉merge commit
   1.  --no-merges
   2.  默认情况下git log会输出merge commit.  你可以通过--no-merges标记来过滤掉merge commit，git log --no-merges
   3.  另外，如果你只对merge commit感兴趣可以使用—merges，git log --merges


10. 按标签tag
    1. git log v1.0 
    2. 直接这样是查询标签之前的commit
    3. 加两个点git log v1.0.. 查询从v1.0以后的提交历史记录(不包含v1.0)


11. 按commit
    1.  git log commit ：查询commit之前的记录，包含commit
    2.  git log commit1 commit2：查询commit1与commit2之间的记录，包括commit1和commit2
    3.  git log commit1..commit2：同上，但是不包括commit1
    4.  其中，commit可以是提交哈希值的简写模式，也可以使用HEAD代替
    5.  HEAD代表最后一次提交，HEAD^为最后一个提交的父提交，等同于HEAD～1
    6.  HEAD～2代表倒数第二次提交
```
